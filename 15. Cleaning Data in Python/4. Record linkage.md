# ==> Comparing strings
## -- Minimum edit distance
- least amount of steps to transform one string into an other by...
  - `insertion`
  - `deletion`
  - `substitution`
  - `transposition`
    - package : `thefuzz`  
```py 
from thefuzz import fuzz
# compare reading vs reeding
fuzz.Wratio('Reeding', 'Reading') #86
'''from 0 to 100 similarity'''

# compare string similarity
# Define string and array of possible matches
string = "Houston Rockets vs Los Angeles Lakers"
choices = pd.Series(['Rockets vs Lakers', 'Lakers vs Rockets',
                    'Houson vs Los Angeles', 'Heat vs Bulls '])
process.extract(string, choices, Limit = 2)
```
# Minimum edit distance
> What is the minimum edit distance from 'sign' to 'sing', and which operation(s) gets you there?
- [ ] 2 by substituting 'g' with 'n' and 'n' with 'g'.
- [x] 1 by transposing 'g' with 'n'.
- [ ] 1 by substituting 'g' with 'n'.
- [ ] 2 by deleting 'g' and inserting a new 'g' at the end.
# The cutoff point
- Import process from thefuzz.
- Store the unique cuisine_types into unique_types.
- Calculate the similarity of 'asian', 'american', and 'italian' to all possible cuisine_types using process.extract(), while returning all possible matches.
```py
# Import process from thefuzz
from thefuzz import process

# Store the unique values of cuisine_type in unique_types
unique_types = restaurants['cuisine_type'].unique()

# Calculate similarity of 'asian' to all values of unique_types
print(process.extract('asian', unique_types, limit = len(unique_types)))

# Calculate similarity of 'american' to all values of unique_types
print(process.extract('american', unique_types, limit = len(unique_types)))

# Calculate similarity of 'italian' to all values of unique_types
print(process.extract('italian', unique_types, limit = len(unique_types)))
```
- Question
> Take a look at the output, what do you think should be the similarity cutoff point when remapping categories?

Possible Answers
- [x] 80
- [ ] 70
- [ ] 60
# Remapping categories II
- Return all of the unique values in the cuisine_type column of restaurants.
```py
# Inspect the unique values of the cuisine_type column
print(restaurants['cuisine_type'].unique())
```
- As a first step, create a list of all possible matches, comparing 'italian' with the restaurant types listed in the cuisine_type column.
```py
# Create a list of matches, comparing 'italian' with the cuisine_type column
matches = process.extract('italian', restaurants['cuisine_type'], limit=len(restaurants.cuisine_type))

# Inspect the first 5 matches
print(matches[0:5])
```
- Within the for loop, use an if statement to check whether the similarity score in each match is greater than or equal to 80.
- If it is, use .loc to select rows where cuisine_type in restaurants is equal to the current match (which is the first element of match), and reassign them to be 'italian'.
```py
# Create a list of matches, comparing 'italian' with the cuisine_type column
matches = process.extract('italian', restaurants['cuisine_type'], limit=len(restaurants))

# Iterate through the list of matches to italian
for match in matches:
  # Check whether the similarity score is greater than or equal to 80
  if match[1]>=80:
    # Select all rows where the cuisine_type is spelled this way, and set them to the correct cuisine
    restaurants.loc[restaurants['cuisine_type'] == match[0], 'cuisine_type'] = 'italian'
```
Finally, you'll adapt your code to work with every restaurant type in categories.
- Using the variable cuisine to iterate through categories, embed your code from the previous step in an outer for loop.
- Inspect the final result. This has been done for you.
```py
# Iterate through categories
for cuisine in categories:  
  # Create a list of matches, comparing cuisine with the cuisine_type column
  matches = process.extract(cuisine, restaurants['cuisine_type'], limit=len(restaurants.cuisine_type))

  # Iterate through the list of matches
  for match in matches:
     # Check whether the similarity score is greater than or equal to 80
    if match[1] >= 80:
      # If it is, select all rows where the cuisine_type is spelled this way, and set them to the correct cuisine
      restaurants.loc[restaurants['cuisine_type'] == match[0]] = cuisine
      
# Inspect the final result
print(restaurants['cuisine_type'].unique())
```
# ==> Generating pairs
```py
import recordlinkage

# create indexing object
indexer = recordlinkage.Index()
# Gnerate pairs blocked in state
Indexer.block('state')
pairs =  Indexer.index(census_A, census_B)

# Create compare Object
compare_cl = recordlinkage.Compare()
# Find exact matches for pairs of date_of-birth and state
compare_cl.exact (' date_of_birth', 'date_of_birth', Label= 'date_of_birth ')
compare_cl.exact (' state', 'state', label= 'state')

# Find similar matches for pairs of surname and address_1 using string similarity
compare_cl.string (' surname", surname", threshold=0.85, label='surname')
compare cl.string (" address_1 ', 'address_1', threshold=0. 85, abel= 'address_1')

#Find matches
potential_matches = compare_cl.compute (pairs, census_A, census_B)
```
### > finding only pairs we want
```py
# 1 is match 0 isn't. Here que want more than 1 col matched 
potential_matches [potential_matches.sum(axis = 1) => 2]
```
